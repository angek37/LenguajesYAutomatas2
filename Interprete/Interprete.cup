import java.io.*;
import java_cup.runtime.*;
import java.util.HashMap;
import java.util.Map;

parser code
{:
  public static void main(String[] args) throws Exception{
    new parser(new Yylex(System.in)).parse();
  }
  public void Syntax_error(Symbol s){
    report_error("Error de sintaxis linea"+ Integer.toString(Yylex.linea+1)+
      "Columna: "+ Integer.toString(Yylex.pos + 1 ) + "En \""+ s.value + "\"", null);
  }
:}

action code
{:
  List l = new List();
:}

terminal GREATER, GREATEREQUAL, LESS, LESSEQUAL, EQUAL, NOTEQUAL;
terminal DIVIDE, TIMES, LPAREN, RPAREN, PLUS, MINUS, AND, OR, NOT;
terminal ID, ASSIGN, SEMI, EXIT;
terminal Boolean TRUE, FALSE;
terminal Integer INTEGER;

non terminal stmt, stmt_part, stmt_list, expr;
non terminal Integer arithm_expr, arithm_term, arithm_factor;
non terminal Boolean relation_expr, log_term, log_factor, bool;


precedence left AND, OR, NOT;
precedence left EQUAL, NOTEQUAL;
precedence left GREATER, GREATEREQUAL, LESS, LESSEQUAL;
precedence left PLUS, MINUS;
precedence left DIVIDE, TIMES;
precedence left ASSIGN;


stmt        ::= stmt stmt_part
            | stmt_part
            ;

stmt_part   ::= stmt_list SEMI
            | error
            {:System.out.println("Error de sintaxis");:}
            ;

stmt_list   ::= expr
            | ID:id ASSIGN expr:data
            {: l.add(""+id, data); :}
            | EXIT
            {: System.exit(1); :}
            ;

expr        ::= log_term
            | relation_expr
            | arithm_expr
            ;

log_term    ::= log_term AND log_factor
            | log_term OR log_factor
            | log_factor
            ;

log_factor  ::= bool
            | NOT log_factor
            | LPAREN log_term RPAREN
            | LPAREN relation_expr RPAREN
            ;

bool        ::= TRUE
            | FALSE
            ;

relation_expr ::= arithm_expr GREATER arithm_expr
            | arithm_expr GREATEREQUAL arithm_expr
            | arithm_expr LESS arithm_expr
            | arithm_expr LESSEQUAL arithm_expr
            | arithm_expr EQUAL arithm_expr
            | arithm_expr NOTEQUAL arithm_expr
            ;
arithm_expr ::= arithm_term
            | arithm_expr:e1 TIMES arithm_term:e2
            {: RESULT = new Integer(e1.intValue() * e2.intValue()); :}
            | arithm_expr:e1 DIVIDE arithm_term:e2
            {: RESULT = new Integer(e1.intValue() / e2.intValue()); :}
            ;

arithm_term ::= arithm_factor
            | arithm_term:e1 PLUS arithm_factor:e2
            {: RESULT = new Integer(e1.intValue() + e2.intValue()); :}
            | arithm_term:e1 MINUS arithm_factor:e2
            {: RESULT = new Integer(e1.intValue() - e2.intValue()); :}
            ;

arithm_factor ::= ID:id
            {:
              if(l.Type(""+id).equals("Integer")){
                RESULT = new Integer((Integer)l.get(""+id));
              }
            :}
            | INTEGER: n
            {: RESULT = n; :}
            | LPAREN arithm_expr RPAREN
            ;
